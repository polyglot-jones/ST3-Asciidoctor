%YAML 1.2
---
# "Asciidoctor.sublime-syntax" v0.0.30 | 2020/11/15
# ==============================================================================
#                        AsciiDoc Syntax for AsciiDoctor
# ==============================================================================
# Syntax definition for AsciiDoctor:
# -- https://asciidoctor.org/
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Copyright (c) Tristano Ajmone, 2019. MIT License.
# ------------------------------------------------------------------------------

name:    AsciiDoc (AsciiDoctor)
comment: AsciiDoc Syntax
file_extensions:
  - ad
  - adoc
  - asciidoc
scope: text.asciidoc

# variables:

contexts:
  main:
  - include: lists
  - include: blocks
  - include: section_titles
  - include: lines
  - include: inline
  - include: characters

#*******************************************************************************
#                                                                              *
#                        D U M M Y   C O N S U M E R S                         *
#                                                                              *
#*******************************************************************************

# Some definitions whose goal is just capturing some elements to prevent false
# positives that break the document. Some of this will later on be replaced with
# proper capturing elemeents, but for now they are needed to keep the syntax
# from falling apart...

  # We need this to consume table option like `[cols="3*^"]`, otherwise the `^`
  # for columns/cells alignments gets parsed as a Superscript opening delimiter,
  # thus breaking up the whole document...
  dummy_table_opts:
    - match: ^\[cols=".*?\]$

#*******************************************************************************
#                                                                              *
#                         B L O C K    E L E M E N T S                         *
#                                                                              *
#*******************************************************************************

  blocks:
    - include: block_literal
    - include: block_comment
    - include: block_listing
    - include: block_source_fenced
    - include: block_sidebar
    - include: block_pass
    - include: block_quote
    - include: block_example
    - include: block_open
      # #- include: '#block_paragraph'           # <- COMMENTED OUT IN ORIGINAL! REMOVED by @bsmith-n4

  ################
  # BLOCK COMMENTS
  ################

  # Examples:
  #   ////
  #   A multi-line comment.
  #   Notice it's a delimited block.
  #   ////

  block_comment:
    - match: ^(/{4,})\s*$\n?
      scope: punctuation.definition.comment.begin.asciidoc
      push:
        - meta_scope: meta.block.comment.content.asciidoc
        - meta_content_scope: comment.block.asciidoc
        - match: ^\1\s*$\n?
          scope: punctuation.definition.comment.end.asciidoc
          pop: true
        # - include: macro



  #################
  # EXAMPLE BLOCKS
  #################
  # Examples:
  #   ====
  #   Lorem ipsum.
  #   ====

  block_example:
    - match: ^(={4,})\s*$\n?
      scope: constant.delimiter.example.begin.asciidoc
      push:
        - meta_scope: meta.block.example.content.asciidoc
        - meta_content_scope: string.unquoted.block.example.asciidoc
        - match: ^\1\s*$\n?
          scope: constant.delimiter.example.end.asciidoc
          pop: true
        - include: lists
        # - include: block_listing
        - include: blocks   # FIXME Is this supposed to be here? It's not in the original, and it looks like a circular reference.
        - include: lines
        - include: inline
        - include: characters

  #     Note: Might need to add more includes.
  #

  ################
  # LISTING BLOCKS
  ################
  # Examples:
  #   [source,python]
  #   ----
  #   print "Lorem ipsum."
  #   ----

  block_listing:
    - match: ^(\-{4,})\s*$\n?
      scope: constant.delimiter.listing.begin.asciidoc
      push:
        - meta_scope: meta.embedded.block.listing.asciidoc
        - meta_content_scope: source.block.listing.content.asciidoc
        - match: ^\1\s*$\n?
          scope: constant.delimiter.listing.end.asciidoc
          pop: true
  #   - include: inline_callout



  ######################
  # FENCED SOURCE BLOCKS
  ######################
  # Fenced code block (ala Markdown)
  #
  # Examples:
  #   ```rb
  #   puts 'Hello world!'
  #   ```

  # TODO: Check if fence delimiter can be more than three backticks.
  # TODO: Add lang name from match regex group.

  block_source_fenced:
    - match: ^(```)(\w+)?\s*$\n?
      scope: constant.delimiter.listing.begin.asciidoc
      push:
        - meta_scope: meta.embedded.block.listing.asciidoc
        - meta_content_scope: source.block.listing.content.asciidoc
        # - match: ^\1\s*($|\n)
        - match: '^\1\s*$\n?'
          scope: constant.delimiter.listing.end.asciidoc
          pop: true
        # - include: inline_callout


  ################
  # LITERAL BLOCKS
  ################
  # Examples: (must be four or more dots, since three dots is an ellipses)
  #   ....
  #   Lorem ipsum.
  #   ....
  block_literal:
    - match: ^(\.{4,})\s*$\n?
      scope: constant.delimiter.block.literal.begin.asciidoc
      push:
        - meta_scope: meta.block.literal.content.asciidoc
        - meta_content_scope: string.literal.block.delimited.asciidoc
        - match: ^\1\s*$\n?
          scope: constant.delimiter.block.literal.end.asciidoc
          pop: true
        # - match: ^.*$\n?
        #   scope: meta.block.literal.content.asciidoc
        # - include: inline_callout
  
  #############
  # OPEN BLOCKS
  #############
  # Examples:
  #   --
  #   Lorem ipsum
  #   --

  block_open:
    - match: ^\-\-\s*$\n?
      scope: constant.delimiter.block.open.begin.asciidoc
      push:
        - meta_scope: meta.block.open.asciidoc
        - meta_content_scope: meta.block.open.content.asciidoc
        - match: ^\-\-\s*$\n?
          scope: constant.delimiter.block.open.end.asciidoc
          pop: true
        # @NOTE ORIGIN: Might need to check on these includes:
        - include: lists
        - include: block_comment
        # - include: block_listing
        - include: block_pass
        - include: lines
        - include: inline
        - include: characters

  
  
  #############
  # PASS BLOCKS
  #############

  block_pass:
    - match: ^(\+{4,})\s*$\n?
      scope: constant.delimiter.block.passthrough.begin.asciidoc
      push:
        - meta_scope: meta.embedded.block.passthrough.asciidoc
        - meta_content_scope: text.xml.block.passthrough.content.asciidoc
        - match: ^\1\s*$\n?
          scope: constant.delimiter.block.passthrough.end.asciidoc
          pop: true
      # - include: text.xml

  
  ##############
  # QUOTE BLOCKS
  ##############
  # Examples:
  #   ____
  #   Lorem ipsum
  #   ____

  block_quote:
    - match: ^(_{4,})\s*$\n?
      scope: constant.delimiter.block.quote.begin.asciidoc
      push:
        - meta_scope: meta.block.quote.content.asciidoc
        - meta_content_scope: markup.quote.block.asciidoc
        - match: ^\1\s*$\n?
          scope: constant.delimiter.block.quote.end.asciidoc
          pop: true
        - include: lines
        - include: inline
        - include: characters
        #  Note: Might need to add more includes.


  #################
  # SIDEBAR BLOCKS
  #################
  # Examples:
  #   ****
  #   Lorem ipsum
  #   ****

  block_sidebar:
    - match: ^(\*{4,})\s*$\n?
      scope: constant.delimiter.block.sidebar.begin.asciidoc
      push:
        - meta_scope: meta.block.sidebar.content.asciidoc
        - meta_content_scope: string.quoted.block.sidebar.asciidoc
        - match: ^\1\s*$\n?
          scope: constant.delimiter.block.sidebar.end.asciidoc
          pop: true
        - include: lists
        - include: block_comment
        - include: block_listing
        - include: lines
        - include: inline
        - include: characters
        #  Note: Might need to add more includes.



# -------------------------------------
# @NOTE: Was commented out in original!
# -------------------------------------
#  #block_paragraph:
#  #  comment: |
#  #    TODO
#  #  name: meta.paragraph.asciidoc
#  #  contentName: constant.character
#  #  begin: ^(?=\S)(?![\/|=\-_\.*`]{2,}(?=\s*$))(?!\.\S+)
#  #  end: ^(?:\s*$|(?=[ ]{,3}>.))|(?=[ \t]*\n)(?<=^===|^====|=====|^---|^----|-----)[\t]*\n

  #################
  # INLINE CALLOUTS
  #################
  # Callout label
  #
  # Examples:
  #   <1>
  #   <42>

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # inline_callout:
  #   comment: |
  #     Callout label
  #
  #     Examples:
  #       <1>
  #       <42>
  #   name: constant.other.callout.asciidoc
  #   match: (?<!\\)(<)\d+(>)
  #   captures:
  #     '1': {name: punctuation.definition.callout.begin.asciidoc}
  #     '2': {name: punctuation.definition.callout.end.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<


#-----------------------------------------------------------------------------#
#                             C H A R A C T E R S                             #
#-----------------------------------------------------------------------------#

  characters:
    - include: attribute_reference
    - include: macro
    - include: biblio_anchor
    - include: entity_number
    - include: entity_name
    - include: escape
    - include: xref
    - include: indexterm_triple
    - include: indexterm_double
  #   - include: replacement
  #   - include: macro_pass

  #####################
  # ATTRIBUTE REFERENCE
  #####################
  # Examples:
  #   {my-attribute}

  attribute_reference:
    - match: ({)([A-Za-z0-9_][A-Za-z0-9_-]*)(})
      captures:
       1: constant.character.attributes.reference.begin.asciidoc
       2: support.variable.attribute.asciidoc
       3: constant.character.attributes.reference.end.asciidoc

  ################
  # BIBLIO ANCHORS
  ################
  # Examples:
  #   [[[Lorem ipsum]]]

  biblio_anchor:
    - match: (?<!\[)(\[\[\[)(.*?)(\]\]\])(?!\])
      captures:
       1: punctuation.definition.biblioanchor.begin.asciidoc
       2: storage.type.reference.biblioanch  or.asciidoc
       3: punctuation.definition.biblioanchor.end.asciidoc

  #################
  # NUMBER ENTITIES
  #################
  # Numeric character reference
  # Examples:
  #   &#x278a;
  #   &#182;

  entity_number:
    - match: (?<!\\)&#(x?[0-9a-fA-f]{2,4});
      scope: constant.character.entity.asciidoc

  ################
  # NAMED ENTITIES
  ################
  # Character entity reference
  #     Examples:
  #   &nbsp;
  #   &sup2;

  entity_name:
    - match: (?<!\\)&([a-zA-Z][a-zA-Z0-9]*);
      scope: constant.character.entity.xml.asciidoc

  #########
  # ESCAPES
  #########
  # In AsciiDoc, certain characters need to be escaped with a backslash.
  # TODO This might not be a complete list of characters need to be escaped.
  # This look-ahead regex determines if any given backslash is acting as such an escape.
  escape:
    - match: \\(?=[-`*_#+.!(){}\[\]\\>:])
      scope: constant.character.escape.asciidoc

  ###################
  # DOUBLE INDEXTERMS
  ###################
  # Double parenthesis indexterm.
  # Examples:
  #   ((Arthur))
  #   (("Doyle, Arthur Conan"))

  indexterm_double:
    - match: (?<!\()(\({2})([^\(\s].*?)(\){2})(?!\))
      captures:
        1: constant.character.indexterm.double.begin.asciidoc
        3: constant.character.indexterm.double.end.asciidoc
      scope: variable.other.indexterm.double.asciidoc

  ###################
  # TRIPLE INDEXTERMS
  ###################
  # Triple parenthesis indexterm.
  # Examples:
  #   (((Sword, Broadsword, Excalibur)))

  indexterm_triple:
    - match: (?<!\()(\({3})([^\(\s].*?)(\){3})(?!\))
      captures:
        1: constant.character.indexterm.triple.begin.asciidoc
        3: constant.character.indexterm.triple.end.asciidoc
      scope: variable.other.indexterm.triple.asciidoc


  ########
  # MACROS
  ########

  # @NOTE (ORIGINAL): There are other macro notations, but I match only those
  #                   that end in square brackets.

  # @NOTE: We should really have a separate definition for links, which allows
  #        attributes and provides link-specific semantics for `title=""` and
  #        the `^` for `target_blank`, etc.

  macro:
    - include: dummy_table_opts # e.g. [cols="3*^"]
    - match: |
        (?x)
        (?:
          ((?:https?|mailto|ftp|file)  # specify separately so we can mark them as links that TextMate opens
          ?:{1}  # inline only
          \S*)   # (others such as image are partial URLs and/or TextMate cannot handle them)
        |
          (([a-zA-Z0-9][a-zA-Z0-9_]*)
          (:{1,2})
          (\S*))
        )
        (?:(\[)([^\]]*)(\]))
      captures:
        1: markup.underline.link.macro.asciidoc
        3: keyword.control.name.macro.asciidoc
        4: constant.character.separator.macro.asciidoc
        5: markup.underline.target.macro.asciidoc
        6: constant.character.attributes.macro.begin.asciidoc
        7: variable.parameter.attributes.macro.asciidoc
        8: constant.character.attributes.macro.end.asciidoc


  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # macro:
  #   comment: |
  #     Note: There are other macro notations, but I match only those that end in
  #     square brackets.
  #   name: meta.macro.asciidoc
  #   match: |-
  #     (?x)
  #     (?:
  #       ((?:https?|mailto|ftp|file)  # specify separately so we can mark them as links that TextMate opens
  #       ?:{1}  # inline only
  #       \S*)   # (others such as image are partial URLs and/or TextMate cannot handle them)
  #     |
  #       (([a-zA-Z0-9][a-zA-Z0-9_]*)
  #       (:{1,2})
  #       (\S*))
  #     )
  #     (?:(\[)([^\]]*)(\]))
  #   captures:
  #     '1': {name: markup.underline.link.macro.asciidoc}
  #     '3': {name: keyword.control.name.macro.asciidoc}
  #     '4': {name: constant.character.separator.macro.asciidoc}
  #     '5': {name: markup.underline.target.macro.asciidoc}
  #     '6': {name: constant.character.attributes.macro.begin.asciidoc}
  #     '7': {name: variable.parameter.attributes.macro.asciidoc}
  #     '8': {name: constant.character.attributes.macro.end.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  ############
  # PASS MACRO
  ############
  # Passthrough macro
  # Examples:
  #   pass:[Lorem ipsum]
  #   pass::[Lorem ipsum]

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # macro_pass:
  #   comment: |
  #     Passthrough macro
  #
  #     Examples:
  #       pass:[Lorem ipsum]
  #       pass::[Lorem ipsum]
  #   name: meta.macro.pass.asciidoc
  #   contentName: variable.parameter.attributes.macro.pass.asciidoc
  #   begin: |-
  #     (?x)
  #     (pass)
  #     (:{1,2})
  #     (\S*)
  #     (\[)(?=[^\]]*\])
  #   captures:
  #     '1': {name: keyword.control.name.macro.pass.asciidoc}
  #     '2': {name: constant.character.separator.macro.asciidoc}
  #     '3': {name: markup.underline.target.macro.asciidoc}
  #     '4': {name: constant.character.attributes.macro.begin.asciidoc}
  #   end: '\]'
  #   endCaptures:
  #     '0': {name: constant.character.attributes.macro.end.asciidoc}
  #   - include: text.xml
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  ##############
  # REPLACEMENTS
  ##############
  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  #  replacement:
  #    name: constant.character.replacement.asciidoc
  #    match: |-
  #      (?x)
  #      (?<!\\)  # must not be escaped
  #      (
  #        \(C\)
  #        | \(TM\)
  #        | \(R\)
  #        | ((?<!\-)\-\-(?!\-))    # exactly two, and even this may not rule out all that I want to
  #        | ((?<!\.)\.\.\.(?!\.))  # exactly three
  #        | \->
  #        | <\-
  #        | =>
  #        | <=
  #      )
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<


  #######
  # XREFS
  #######
  # Internal cross-reference
  # Examples:
  #   <<lorem>>
  #   <<lorem, see here>>

  xref:
    - match: (?<!<)(<<)([^,]*?,\s*)((.*?))?(>>)(?!<)
      captures:
        1: constant.character.xref.begin.asciidoc
        2: variable.parameter.xref.link.asciidoc
        4: variable.parameter.xref.display.asciidoc
        5: constant.character.xref.end.asciidoc
      scope: meta.xref.asciidoc

#*******************************************************************************
#                                                                              *
#                        I N L I N E    E L E M E N T S                        *
#                                                                              *
#*******************************************************************************

  inline:
    - include: passthrough
    - include: curly_quote_double
    - include: curly_quote_single
    - include: strong_double
    - include: emphasis_double
    - include: monospaced_double
    - include: mark_double
    - include: strong
    - include: emphasis
    - include: monospaced
    # - include: mark           # problematic!
    - include: superscript    # problematic!
    - include: subscript
    - include: attribute_list



  ######################
  # ATTRIBUTE LIST
  ######################
  # Emphasized (italic) text (constrained variant).
  #
  # Examples:
  #   [Lorem ipsum] dolor
  #   [red] Lorem ipsum dolor

  attribute_list:
    - match: |
        (?x)
        (\[[^\]]*?\])?      # might be preceded by an attributes list
        (?<=^|\W)(?<!\\|})  # must be preceded by nonword character, and not by escape or } (attribute)
      captures:
        1: support.variable.attributelist.asciidoc


  ####################
  # TYPOGRAPHIC QUOTES
  ####################
  # IMPORTANT: These must appear before monospaced.
  #
  # Examples:
  #   "`And then he said, '`Tally Ho!`', and off he went.`"

  curly_quote_double:
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with an attribute list
        (?<!\\)         # must not be preceded by escape
        ("`)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.curlyquote.double.begin.asciidoc
      push: inside_curly_quote_double

  inside_curly_quote_double:
    - meta_content_scope: markup.curlyquote.double.asciidoc
    - meta_scope: meta.curlyquoteinner.double.asciidoc
    - include: strong_double
    - include: strong
    - include: emphasis_double
    - include: emphasis
    - include: monospaced_double
    - include: monospaced
    - match: (`")
      scope: punctuation.definition.curlyquote.double.end.asciidoc
      pop: true

  curly_quote_single:
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with an attribute list
        (?<!\\)         # must not be preceded by escape
        ('`)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.curlyquote.single.begin.asciidoc
      push: inside_curly_quote_single

  inside_curly_quote_single:
    - meta_content_scope: markup.curlyquote.single.asciidoc
    - meta_scope: meta.curlyquoteinner.single.asciidoc
    - include: strong_double
    - include: strong
    - include: emphasis_double
    - include: emphasis
    - include: monospaced_double
    - include: monospaced
    - match: (`')
      scope: punctuation.definition.curlyquote.double.end.asciidoc
      pop: true





  ######################
  # STRONG UNCONSTRAINED
  ######################
  # Was: "STRONG DOUBLE"
  # Strong (bold) text (unconstrained variant).
  # Examples:
  #   Lo**re**m **ipsum dolor**.
  #   Lo[red]**re**m

  strong_double:
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with an attribute list
        (?<!\\)         # must not be preceded by escape
        (\*\*)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.bold.double.begin.asciidoc
      push: inside_strong_double

  inside_strong_double:
    - meta_content_scope: markup.bold.double.asciidoc
    - meta_scope: meta.boldinner.double.asciidoc
    - include: error_on_empty_line
    - include: line_comment
    - include: emphasis_double
    - include: emphasis
    - include: monospaced_double
    - include: monospaced
    - match: \*\*
      scope: punctuation.definition.bold.double.end.asciidoc
      pop: true
      #   - include: emphasis_double
      #   - include: monospaced_double
      #   - include: mark_double
      #   - include: emphasis
      #   - include: monospaced
      #   - include: mark
      #   - include: superscript
      #   - include: subscript
      #   - include: characters


  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # strong_double:
  #   comment: |
  #     Strong (bold) text (unconstrained variant).
  #
  #     Examples:
  #       Lo**re**m **ipsum dolor**.
  #       Lo[red]**re**m
  #   name: markup.bold.double.asciidoc
  #   contentName: meta.boldinner.double.asciidoc
  #   begin: |-
  #     (?x)
  #     (\[[^\]]*?\])?  # might start with an attribute list
  #     (?<!\\)         # must not be preceded by escape
  #     (\*\*)
  #   beginCaptures:
  #     '1': {name: support.variable.attributelist.asciidoc}
  #     '2': {name: punctuation.definition.bold.double.begin.asciidoc}
  #   end: '\*\*'
  #   endCaptures:
  #     '0': {name: punctuation.definition.bold.double.end.asciidoc}
  #   - include: emphasis_double
  #   - include: monospaced_double
  #   - include: mark_double
  #   - include: emphasis
  #   - include: monospaced
  #   - include: mark
  #   - include: superscript
  #   - include: subscript
  #   - include: characters
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  #####################
  # STRONG CONSTRAINED
  #####################
  # Was: "STRONG"
  # Strong (bold) text (unconstrained variant).
  # Examples:
  #   *Lorem ipsum* dolor
  #   [red]*Lorem ipsum* dolor
  strong:
    - match: |
        (?x)
        (\[[^\]]*?\])?      # might start with an attributes list
        (?<=^|\W)(?<!\\|})  # must be preceded by nonword character, and not by escape or } (attribute)
        (\*)(?=\S)          # delimiter star that must be followed by a nonspace character
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.bold.single.begin.asciidoc
      push: inside_strong

  inside_strong:
    - meta_content_scope: markup.bold.single.asciidoc
    - meta_scope: meta.boldinner.single.asciidoc
    - include: error_on_empty_line
    - include: line_comment
    - include: emphasis_double
    - include: emphasis
    - include: monospaced_double
    - include: monospaced
    - match: |
        (?x)
        (?<=\S)(\*)       # delimiter star that must be preceded by a nonspace character
        (?!\w)            # ...and followed by a nonword character
      scope: punctuation.definition.bold.single.end.asciidoc
      pop: true
      #   - include: emphasis_double
      #   - include: monospaced_double
      #   - include: mark_double
      #   - include: emphasis
      #   - include: monospaced
      #   - include: mark
      #   - include: superscript
      #   - include: subscript
      #   - include: characters



  ########################
  # EMPHASIS UNCONSTRAINED
  ########################
  # Was: "EMPHASIS DOUBLE"
  # Emphasized (italic) text (unconstrained variant).
  # Examples:
  #   Lo__re__m __ipsum dolor__.
  #   Lo[red]__re__m

  emphasis_double:
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with attribute list
        (?<!\\)         # must not be preceded by escape
        (__)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.italic.double.begin.asciidoc
      push: inside_emphasis_double

  inside_emphasis_double:
    - meta_content_scope: markup.italic.double.asciidoc
    - meta_scope: meta.italicinner.double.asciidoc
    - include: error_on_empty_line
    - include: line_comment
    - include: strong_double
    - include: strong
    - include: monospaced_double
    - include: monospaced
    - match: '__'
      scope: punctuation.definition.italic.double.end.asciidoc
      pop: true
    #   - include: strong_double
    #   - include: monospaced_double
    #   - include: mark_double
    #   - include: strong
    #   - include: monospaced
    #   - include: mark
    #   - include: superscript
    #   - include: subscript
    #   - include: characters



  ######################
  # EMPHASIS CONSTRAINED
  ######################
  # Was: "EMPHASIS"
  # Emphasized (italic) text (constrained variant).
  #
  # Examples:
  #   _Lorem ipsum_ dolor
  #   [red]_Lorem ipsum_ dolor

  emphasis:
    - match: |
        (?x)
        (\[[^\]]*?\])?      # might be preceded by an attributes list
        (?<=^|\W)(?<!\\|})  # must be preceded by nonword character, and not by escape or } (attribute)
        (_)(?=\S)           # delimiter underscore that must be followed by a nonspace character
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.italic.single.begin.asciidoc
      push: inside_emphasis

  inside_emphasis:
    - meta_content_scope: markup.italic.single.asciidoc
    - meta_scope: meta.italicinner.single.asciidoc
    - include: error_on_empty_line
    - include: line_comment
    - include: strong_double
    - include: strong
    - include: monospaced_double
    - include: monospaced
    - match: |
        (?x)
        (?<=\S)(_)        # delimiter underscore that must be preceded by a nonspace character
        (?!\w)            # ...and followed by a nonword character
      scope: punctuation.definition.italic.single.end.asciidoc
      pop: true
    # - include: strong_double
    # - include: monospaced_double
    # - include: mark_double
    # - include: strong
    # - include: monospaced
    # - include: mark
    # - include: superscript
    # - include: subscript
    # - include: characters



  ##########################
  # MONOSPACED UNCONSTRAINED
  ##########################
  # Was: "MONOSPACED DOUBLE"
  # Monospaced text (unconstrained variant).
  #
  # Examples:
  #   Lo``re``m ``ipsum dolor``.
  #   Lo[red]``re``m

  monospaced_double:
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with attribute list
        (?<!\\)         # must not be preceded by escape
        (``)
        (?!"|')         # Avoid false positive for closing smart typography
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.literal.double.begin.asciidoc
      push: inside_monospaced_double

  inside_monospaced_double:
    - meta_content_scope: string.other.literal.double.asciidoc
    - meta_scope: meta.literalinner.double.asciidoc
    - include: error_on_empty_line
    - include: line_comment
    - match: '``'
      scope: punctuation.definition.literal.double.end.asciidoc
      pop: true
    # - include: strong_double
    # - include: emphasis_double
    # - include: mark_double
    # - include: strong
    # - include: emphasis
    # - include: mark
    # - include: superscript
    # - include: subscript
    # - include: characters



  ########################
  # MONOSPACED CONSTRAINED
  ########################
  # Was: "MONOSPACED"
  # Monospaced text (constrained variant).
  #
  # Examples:
  #   `Lorem ipsum` dolor
  #   [red]`Lorem ipsum` dolor

  monospaced:
    # False positive: typographic quotes followed by single backtick:
    - match: (["']`)(`(?!`))?
      captures:
        1: punctuation.definition.string.begin.asciidoc
      pop: true
    # False positive: closing typographic quotes:
    - match: (`["'])
      captures:
        1: punctuation.definition.string.end.asciidoc
      pop: true
    # Capture real monospaced formatting:
    - match: |
        (?x)
        (\[[^\]]*?\])?      # might start with attributes list
        (?<=^|\W)(?<!\\|})  # must be preceded by nonword character, and not by escape or } (attribute)
        (`)(?=\S)           # delimiter backtick that must be followed by a nonspace character
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.literal.single.begin.asciidoc
      push: inside_monospaced

  inside_monospaced:
    - meta_content_scope: string.other.literal.single.asciidoc
    - meta_scope: meta.literalinner.single.asciidoc
    - include: error_on_empty_line
    - include: line_comment
    - match: |
        (?x)
        (?<=\S)(`)        # delimiter backtick that must be preceded by a nonspace character
        (?!\w)            # ...and followed by a nonword character
      scope: punctuation.definition.literal.single.end.asciidoc
      pop: true
  #   - include: strong_double
  #   - include: emphasis_double
  #   - include: mark_double
  #   - include: strong
  #   - include: emphasis
  #   - include: mark
  #   - include: superscript
  #   - include: subscript
  #   - include: characters





  #############
  # PASSTHROUGH
  #############
  # Inline triple-plus and double dollar passthrough.
  # Examples:
  #   Lo+++re++++m +++ipsum dolor+++.
  #   Lo$$re$$m $$ipsum dolor$$.

  # @NOTE ORIGINAL: Must be dead-first among the inlines, so as to take priority.

  passthrough:
    - match: (\+\+\+|\$\$)
      scope: constant.character.passthrough.begin.asciidoc
      push:
        - meta_scope: meta.passthrough.inline.asciidoc
        - meta_content_scope: variable.parameter.passthroughinner.asciidoc
        - match: \1
          scope: constant.character.passthrough.end.asciidoc
          pop: true



  ####################
  # MARK UNCONSTRAINED
  ####################
  # Was: "MARK DOUBLE"
  # Marked text (unconstrained variant).
  # Examples:
  #   Lo##re##m ##ipsum dolor##.
  #   Lo[red]##re##m

  mark_double:
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with an attribute list (indeed, that is its purpose)
        (?<!\\)         # must not be preceded by escape
        (\#\#)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.string.unquoted.double.begin.asciidoc
      push:
        - meta_scope: string.other.unquoted.double.asciidoc
        - meta_content_scope: string.unquoted.unquotedinner.double.asciidoc
        - match: \#\#
          scope: punctuation.definition.string.unquoted.double.end.asciidoc
          pop: true
        #   - include: strong_double
        #   - include: emphasis_double
        #   - include: monospaced_double
        #   - include: strong
        #   - include: emphasis
        #   - include: monospaced
        #   - include: superscript
        #   - include: subscript
        #   - include: characters



  ##################
  # MARK CONSTRAINED
  ##################
  # Was: "MARK"
  # Marked text (constrained variant).
  # Examples:
  #   #Lorem ipsum# dolor
  #   [red]#Lorem ipsum# dolor

  # @PROBLEM: Breaks everything! seems like optional "start with attribute"
  #           causes anything to match anything else!
#  mark:
#    - match: |
#        (?x)
#        (\[[^\]]*?\])?      # might start with attribute list (darned well better or why are we here)
#        (?<=^|\W)(?<!\\|})  # must be preceded by nonword character, and not by escape or } (attribute)
#        (\#)(?=\S)          # delimiter hash that must be followed by a nonspace character
#      captures:
#        1: support.variable.attributelist.asciidoc
#        2: punctuation.definition.string.unquoted.single.begin.asciidoc
#      push:
#        - meta_scope: string.other.unquoted.single.asciidoc
#        - meta_content_scope: string.unquoted.unquotedinner.single.asciidoc
#        - match: |
#            (?x)
#            (?<=\S)(\#)       # delimiter hash that must be preceded by a nonspace character
#            (?!\w)            # ...and followed by a nonword character
#          scope: punctuation.definition.string.unquoted.single.end.asciidoc
#          pop: true
#        # - include: strong_double
#        # - include: emphasis_double
#        # - include: monospaced_double
#        # - include: strong
#        # - include: emphasis
#        # - include: monospaced
#        # - include: superscript
#        # - include: subscript
#        # - include: characters


  ###########
  # SUBSCRIPT
  ###########
  # Subscript text.
  # Examples:
  #   H~2~O
  #   H[red]~2~O

  subscript:
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with attribute list
        (?<!\\)         # must not be preceded by escape
        (~)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.string.subscript.begin.asciidoc
      push:
        - meta_scope: meta.subscriptinner.asciidoc
        - meta_content_scope: string.other.subscript.asciidoc
        - match: \~
          scope: punctuation.definition.string.subscript.end.asciidoc
          pop: true
      #   - include: strong_double
      #   - include: emphasis_double
      #   - include: monospaced_double
      #   - include: mark_double
      #   - include: strong
      #   - include: emphasis
      #   - include: monospaced
      #   - include: mark
      #   - include: superscript
      #   - include: characters



  #############
  # SUPERSCRIPT
  #############
  # Superscript text.
  # Examples:
  #   E=mc^2^
  #   E=mc[red]^2^

  superscript:
    - match: |
        (?x)
        (\[[^\]]*?\])?  # might start with attribute list
        (?<!\\)         # no preceding escape
        (\^)
      captures:
        1: support.variable.attributelist.asciidoc
        2: punctuation.definition.string.superscript.begin.asciidoc
      push:
        - meta_scope: meta.superscriptinner.asciidoc
        - meta_content_scope: string.other.superscript.asciidoc
        - match: \^
          scope: punctuation.definition.string.superscript.end.asciidoc
          pop: true
      #   - include: strong_double
      #   - include: emphasis_double
      #   - include: monospaced_double
      #   - include: mark_double
      #   - include: strong
      #   - include: emphasis
      #   - include: monospaced
      #   - include: mark
      #   - include: subscript
      #   - include: characters



#*******************************************************************************
#                                                                              *
#                   S I N G L E - L I N E    E L E M E N T S                   *
#                                                                              *
#*******************************************************************************

  lines:
    - include: line_comment
    - include: list_continuation
    - include: inline_break
    - include: block_page_break
    - include: block_thematic_break
    - include: block_title
    - include: block_id
  #   - include: block_req                              # <- ADDED by @bsmith-n4
  #   - include: section_template
  #   - include: attribute_list_line
    - include: attribute_entry

  ######################
  # SINGLE-LINE COMMENTS
  ######################
  # Inline comment. (?)
  # Examples:
  #   // This is just a comment!
  line_comment:
    - match: ^(//)([^/\n].*|)$\n?
      scope: comment.line.double-slash.asciidoc
      captures:
        1: punctuation.definition.comment.line.asciidoc
        2: meta.line.comment.content.asciidoc

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # inline_comment:
  #   comment: |
  #     Inline comment.
  #
  #     Examples:
  #       // This is just a comment!
  #   name: comment.line.double-slash.asciidoc
  #   match: ^(//)([^/\n].*|)$\n?
  #   captures:
  #     '1': {name: punctuation.definition.comment.line.asciidoc}
  #     '2': {name: meta.line.comment.content.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  #################
  # ATTRIBUTE ENTRY
  #################
  # An attribute entry.
  # Examples:
  #   :my-attribute: value
  #   :sectnums!:
  #   :!sectnums:

  attribute_entry:
    - match: |
        (?x)
        ^(:)                          # 1: opening delimiter
        (!)?                          # 2: bang symbol (unset attribute)
        ([A-Za-z0-9_][A-Za-z0-9_-]*)  # 3: attribute name
        (!)?                          # 4: bang symbol (unset attribute)
        (:)                           # 5: closing delimiter
        (?:\s+|(?=$))                 # ? consume WS?
      captures:
        1: punctuation.definition.attributeentry.attrname.begin.asciidoc
        2: punctuation.definition.attributeentry.unset.asciidoc
        3: support.variable.attribute.asciidoc
        4: punctuation.definition.attributeentry.unset.asciidoc
        5: punctuation.definition.attributeentry.attrname.end.asciidoc
      push:
        - meta_scope: meta.attributeentry.asciidoc
        - meta_content_scope: meta.attributeentry.value.asciidoc
        - match: $\n?
          pop: true
        #   - include: characters


  #####################
  # ATTRIBUTE LIST LINE
  #####################
  # Attribute list as paragraph: single brackets. No need for special
  # treatment of escape; follows literal block, section template as being a
  # more general regex.

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # attribute_list_line:
  #   comment: >
  #     Attribute list as paragraph: single brackets. No need for special
  #     treatment of escape; follows literal block, section template as being a
  #     more general regex.
  #   name: support.variable.attributelist.asciidoc
  #   match: ^(\[)[^\[\]]*(\])\s*$\n?
  #   captures:
  #     '1': {name: punctuation.definition.attributelistline.begin.asciidoc}
  #     '2': {name: punctuation.definition.attributelistline.end.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

  #############
  # BLOCK TITLE
  #############
  # Title of a block. Excludes custom block titles for better
  # scoping / preventing overlap.
  # Examples:
  #   .My title
  #   Lorem ipsum dolor.

  block_title:
    - match: ^(\.)(\w.*)$\n?
      captures:
        1: punctuation.definition.blockheading.asciidoc
        2: markup.heading.block.asciidoc


  ##########
  # BLOCK ID
  ##########
  # A block id (i.e. anchor).
  # Examples:
  #   [[myid]]
  #   Lorem ipsum dolor.

  block_id:
    - match: ^(\[\[)([^\[].*)(\]\])\s*$\n?
      captures:
        0: meta.tag.blockid.asciidoc
        1: punctuation.definition.blockid.begin.asciidoc
        2: markup.anchor.blockid.id.asciidoc
        3: punctuation.definition.blockid.end.asciidoc


  ###########
  # BLOCK REQ
  ###########
  # A requirement id (i.e. anchor).
  # Examples:
  #   [req,id=ROPR1234,version=1]
  #   Lorem ipsum dolor.

  # IMPORTANT: This element was ADDED by @bsmith-n4!

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>                         # <- ADDED by @bsmith-n4
  # block_req:
  #   comment: |
  #     A requirement id (i.e. anchor).
  #     Examples:
  #       [req,id=ROPR1234,version=1]
  #       Lorem ipsum dolor.
  #   name: meta.tag.blockid.req.asciidoc
  #   match: (\[req,(\s+)?id=)(.+?)(,(\s+)?version=)([0-9])(\])
  #   captures:
  #     '1': {name: markup.anchor.block.id.asciidoc}
  #     '3': {name: variable.parameter.reqid.id.asciidoc}
  #     '4': {name: markup.anchor.block.version.asciidoc}
  #     '6': {name: variable.parameter.reqversion.id.asciidoc}
  #     '7': {name: markup.anchor.block.id.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<


  ##############
  # INLINE BREAK
  ##############
  # Line hard break with a plus sign (+).
  # Examples:
  #   Rubies are red, +
  #   Topazes are blue.

  inline_break:
    - match: (?<=\s)\+$\n?
      scope: constant.linebreak.asciidoc



  ###################
  # LIST CONTINUATION
  ###################
  # See: §20.2.1. List continuation
  # https://asciidoctor.org/docs/user-manual/#list-continuation

  # Examples:
  #  * First list element paragraph.
  #  +
  #  Second element paragraph (no bullet).

  list_continuation:
    - match: ^\+\s*$\n?
      scope: constant.listcontinuation.asciidoc


  ##################
  # BLOCK PAGE BREAK
  ##################
  # A page break.
  # Examples:
  #   <<<
  #   <<<<<

  block_page_break:
    - match: ^<{3,}$\n?
      scope: meta.separator.pagebreak.asciidoc


  ######################
  # BLOCK THEMATIC BREAK
  ######################
  # A thematic break (aka horizontal rule).
  # Examples:
  #   '''
  #   ''''''

  block_thematic_break:
    - match: ^'{3,}$\n?
      scope: meta.separator.ruler.asciidoc



  ##################
  # SECTION TEMPLATE
  ##################
  # Fixed list of known template names
  # See: §16.9. Section Styles
  # https://asciidoctor.org/docs/user-manual/#section-styles

  # IMPORTANT: This element differs in @bsmith-n4 and original!
  #
  # section_template:
  #   comment: fixed list of known template names
  #   name: variable.parameter.sectiontemplate.asciidoc
  #   match: |-



  # >>>>>>>>>>>>>>>>>>>>>>>>>>>
  # section_template:
  #   comment: fixed list of known template names
  #   name: variable.parameter.sectiontemplate.asciidoc
  #   match: |                       # <- CHANGED by @bsmith-n4 (was: match: |-)
  #     (?x)^
  #     (\[)  # in square brackets
  #     (template\s*=\s*)?(")?  # might start with template-equals and might have template name in quotes
  #     (
  #     sect\d|abstract|preface|colophon|dedication|glossary|bibliography|synopsis|appendix|index # fixed list of known templates
  #     )
  #     (".*(\])|(\]))  # either close the quote (and perhaps go on) and close the bracket, or close the bracket immediately
  #     \s*$\n?
  #   captures:
  #     '1': {name: punctuation.definition.sectiontemplate.begin.asciidoc}
  #     '4': {name: meta.tag.sectiontemplate.asciidoc}
  #     '6': {name: punctuation.definition.sectiontemplate.end.asciidoc}
  #     '7': {name: punctuation.definition.sectiontemplate.end.asciidoc}
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<

#*******************************************************************************
#                                                                              *
#                                  L I S T S                                   *
#                                                                              *
#*******************************************************************************
# NOTE: For lists (and similar), we don't to try to match on the entire
#       paragraph, just the opening syntax.

  lists:
    - include: ulist_item_marker
    - include: olist_item_marker
    - include: colist_item_marker
    - include: dlist_item_label
    - include: block_admonition_label
  

  ########################
  # ADMONITION BLOCK LABEL
  ########################
  # Label of an admonition block.
  # Examples:
  #   NOTE: This is a admonition block.
  #   WARNING:  Be aware of them!

  block_admonition_label:
    - match: ^(NOTE|TIP|IMPORTANT|WARNING|CAUTION):(?=\s+)
      scope: support.constant.admonitionword.asciidoc


  ###################
  # ULIST ITEM MARKER
  ###################
  # Marker of an unordered (bullet) list item.
  # Examples:
  #   - level 1
  #   * level 1
  #   ** level 2
  #   *** level 3
  #   **** level 4
  #   ***** level 5

  ulist_item_marker:
    - match: ^\s*(\-|\*{1,5})\s+(?=\S)
      captures:
        1: punctuation.definition.list.bullet.asciidoc

# Markdwon scopes:
#    text.html.markdown.gfm
#    markup.list.unnumbered.markdown
#    punctuation.definition.list_item.markdown

      # scope: markup.list.bulleted.asciidoc


  ####################
  # COLIST ITEM MARKER
  ####################
  # Marker of a callout list item.
  # Examples:
  #   <1> a callout
  #   <42> another callout

  colist_item_marker:
    - match: ^(\s*((<)\d+?(>)))\s+(?=\S)
      captures:
        1: string.unquoted.list.callout.asciidoc
        2: constant.numeric.callout.asciidoc
        3: punctuation.definition.calloutlistnumber.begin.asciidoc
        4: punctuation.definition.calloutlistnumber.end.asciidoc

  ##################
  # DLIST ITEM LABEL
  ##################
  # Label of a definition (labeled) list item.
  # Examples:
  #   Label level 1:: lorem ipsum
  #   Label level 2::: dolor sit amet
  #   Label level 3:::: consectetur
  #   Label level 1::
  #     lorem ipsum
  #   Another label :: lorem ipsum
  #   Last::label:: dolor sit amet

  # @NOTE (ORIGINAL):
  #     This rule is not strictly correct, because AsciiDoctor allows
  #     double colon followed by a space inside a label, i.e. it matches the
  #     *last* double colon, not the first. I don't know how to do that
  #     *effectively.
  dlist_item_label:
    - match: .*(:{2,4})(?:\s|$\n?)
      captures:
        1: punctuation.definition.list.labeled.asciidoc

  ###################
  # OLIST ITEM MARKER
  ###################
  # Marker of an ordered (numbered) list item.
  # Examples:
  #   . level 1
  #   .. level 2
  #   ... level 3
  #   .... level 4
  #   ..... level 5

  olist_item_marker:
    - match: ^\s*(\.{1,5})\s+(?=\S)
      captures:
        1: punctuation.definition.list.numbered.asciidoc


# ==============================================================================
#                          S E C T I O N    T I T L E S
# ==============================================================================

# IMPORTANT: All Titles RegExs were tweaked by @bsmith-n4! Basically, every
#            RegEx was tweaked to allow inline code inside the title:
#
#               match: ^(=) (\w.*)$\n?     <-- original
#               match: ^(=) (`?\w.*)$\n?   <-- @bsmith-n4


#     Examples:
#
#       = Document Title (Level 0)
#
#       == Level 1 Section
#
#       === Level 2 Section
#
# FIXME Do "markup.heading.level.1.asciidoc" etc. really need "level"? I think "markup.heading.1.asciidoc" should suffice, plus it's what I've seen color schemes expect. -- polyglot-jones
# FIXME How about changing "markup.heading.level.0.asciidoc" "markup.title.asciidoc"? -- polyglot-jones

  section_titles:
    - include: title_level_5
    - include: title_level_4
    - include: title_level_3
    - include: title_level_2
    - include: title_level_1
    - include: title_level_0

  title_level_0:
    - match: ^(=)\s+(`?\w.*)$\n?
      scope: markup.heading.level.0.asciidoc
      captures:
        1: punctuation.definition.heading.asciidoc
        2: entity.name.section.asciidoc

  title_level_1:
    - match: ^(==)\s+(`?\w.*)$\n?
      scope: markup.heading.level.1.asciidoc
      captures:
        1: punctuation.definition.heading.asciidoc
        2: entity.name.section.asciidoc


  title_level_2:
    - match: ^(===)\s+((`\w)?.*)$\n?
      scope: markup.heading.level.2.asciidoc
      captures:
        1: punctuation.definition.heading.asciidoc
        2: entity.name.section.asciidoc


  title_level_3:
    - match: ^(====)\s+(`?\w.*)$\n?
      scope: markup.heading.level.3.asciidoc
      captures:
        1: punctuation.definition.heading.asciidoc
        2: entity.name.section.asciidoc

  title_level_4:
    - match: ^(=====)\s+(`?\w.*)$\n?
      scope: markup.heading.level.4.asciidoc
      captures:
        1: punctuation.definition.heading.asciidoc
        2: entity.name.section.asciidoc

  title_level_5:
    - match: ^(======)\s+(`?\w.*)$\n
      scope: markup.heading.level.5.asciidoc
      captures:
        1: punctuation.definition.heading.asciidoc
        2: entity.name.section.asciidoc


#*******************************************************************************
#                                                                              *
#                              R E U S A B L E S                               *
#                                                                              *
#*******************************************************************************
# Reusable contexts...

  #####################
  # ERROR ON EMPTY LINE
  #####################
  # Some element (e.g. quotes) can span multiple lines as long as no empty line
  # is placed between the opening and closing delimiter...
  error_on_empty_line:
    - match: ^\n$
      scope: invalid.illegal.asciidoc
      pop: true

  ##############
  # ANY COMMENTS     ( UNUSED! )
  ##############
  # Include any type of comments.
  any_comments:
    - include: line_comment
    - include: block_comment

#*******************************************************************************
#                                                                              *
#                            M I S C E L A N N E A                             *
#                                                                              *
#*******************************************************************************
# Various definitions added by me, some of which still unused except for tests!



# /// EOF ///

